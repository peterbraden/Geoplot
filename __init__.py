import os
from PIL import Image, ImageDraw

import settings



def to_coord(location, dim, projection = 'plate-caree'):
	"""
	Convert location:(lat, long) to coord:(x, y) on image with dimensions dim.
	"""
	if projection == 'plate-caree':#Plate Caree simply allows 1:1 mapping of long/lat to x/y
		return ((location[1]+180.0) * (dim[0]/360.0) ,((location[0] * -1.0) + 90.0) * (dim[1] / 180.0))
	else:
		raise NotImplementedError, "Projection Not Implemented"

		

DATA = {
	#style : zoom, name, file, image_coords, viewport_coords, world_dimensions

	'blue-marble' : [
		#Hand Tuned Prefererable
		(0, 'world', 'geoplot/data/blue_marble/world.jpg', (0,0,1280,640), (0,0,1280,640), (1280,640)),
		(1, 'north-america', 'geoplot/data/blue_marble/north-america.jpg', (100,148,1380,788), (100,148,1380,788), (3780,1890)),
		(2, 'europe', 'geoplot/data/blue_marble/europe.jpg', (2010,258,3290,1428), (2010,258,3290,1428), (5120,2560)),
		
		#Autogenerated
		(1, 'z1-0x0', 'geoplot/data/blue_marble/z1-0x0.jpg', (0, 0, 1280, 640), (0, 0, 1280, 640), (2560, 1280)),
		(1, 'z1-0x640', 'geoplot/data/blue_marble/z1-0x640.jpg', (0, 640, 1280, 1280), (0, 640, 1280, 1280), (2560, 1280)),
		(1, 'z1-1280x0', 'geoplot/data/blue_marble/z1-1280x0.jpg', (1280, 0, 2560, 640), (1280, 0, 2560, 640), (2560, 1280)),
		(1, 'z1-1280x640', 'geoplot/data/blue_marble/z1-1280x640.jpg', (1280, 640, 2560, 1280), (1280, 640, 2560, 1280), (2560, 1280)),
		(2, 'z2-0x0', 'geoplot/data/blue_marble/z2-0x0.jpg', (0, 0, 1280, 640), (0, 0, 1280, 640), (5120, 2560)),
		(2, 'z2-0x640', 'geoplot/data/blue_marble/z2-0x640.jpg', (0, 640, 1280, 1280), (0, 640, 1280, 1280), (5120, 2560)),
		(2, 'z2-1280x0', 'geoplot/data/blue_marble/z2-1280x0.jpg', (1280, 0, 2560, 640), (1280, 0, 2560, 640), (5120, 2560)),
		(2, 'z2-1280x640', 'geoplot/data/blue_marble/z2-1280x640.jpg', (1280, 640, 2560, 1280), (1280, 640, 2560, 1280), (5120, 2560)),
		(2, 'z2-0x1280', 'geoplot/data/blue_marble/z2-0x1280.jpg', (0, 1280, 1280, 1920), (0, 1280, 1280, 1920), (5120, 2560)),
		(2, 'z2-0x1920', 'geoplot/data/blue_marble/z2-0x1920.jpg', (0, 1920, 1280, 2560), (0, 1920, 1280, 2560), (5120, 2560)),
		(2, 'z2-1280x1280', 'geoplot/data/blue_marble/z2-1280x1280.jpg', (1280, 1280, 2560, 1920), (1280, 1280, 2560, 1920), (5120, 2560)),
		(2, 'z2-1280x1920', 'geoplot/data/blue_marble/z2-1280x1920.jpg', (1280, 1920, 2560, 2560), (1280, 1920, 2560, 2560), (5120, 2560)),
		(2, 'z2-2560x0', 'geoplot/data/blue_marble/z2-2560x0.jpg', (2560, 0, 3840, 640), (2560, 0, 3840, 640), (5120, 2560)),
		(2, 'z2-2560x640', 'geoplot/data/blue_marble/z2-2560x640.jpg', (2560, 640, 3840, 1280), (2560, 640, 3840, 1280), (5120, 2560)),
		(2, 'z2-3840x0', 'geoplot/data/blue_marble/z2-3840x0.jpg', (3840, 0, 5120, 640), (3840, 0, 5120, 640), (5120, 2560)),
		(2, 'z2-3840x640', 'geoplot/data/blue_marble/z2-3840x640.jpg', (3840, 640, 5120, 1280), (3840, 640, 5120, 1280), (5120, 2560)),
		(2, 'z2-2560x1280', 'geoplot/data/blue_marble/z2-2560x1280.jpg', (2560, 1280, 3840, 1920), (2560, 1280, 3840, 1920), (5120, 2560)),
		(2, 'z2-2560x1920', 'geoplot/data/blue_marble/z2-2560x1920.jpg', (2560, 1920, 3840, 2560), (2560, 1920, 3840, 2560), (5120, 2560)),
		(2, 'z2-3840x1280', 'geoplot/data/blue_marble/z2-3840x1280.jpg', (3840, 1280, 5120, 1920), (3840, 1280, 5120, 1920), (5120, 2560)),
		(2, 'z2-3840x1920', 'geoplot/data/blue_marble/z2-3840x1920.jpg', (3840, 1920, 5120, 2560), (3840, 1920, 5120, 2560), (5120, 2560)),

	],
}	

def choose_image(lookat, zoom, style = 'blue-marble'):
	for d in DATA[style]:
		c = map(int, to_coord(lookat, d[5]))
		if d[0] == zoom:
			if d[4][0] <= c[0] < d[4][2] and d[4][1] < c[1] < d[4][3]:
				return d
	raise NotImplementedError, "No imagery for that zoom level"
	




def get_map_image(size, lookat, zoom, style = 'blue-marble'):
	"""
		For now assume blue marble imagery
	"""
	dat = choose_image(lookat, zoom)

	im_path = os.path.join(settings.HOME, dat[2])	
			
	im = Image.open(im_path)		
	
	old_size = im.size[:]
	im.thumbnail(size, Image.ANTIALIAS)
	scale_fac = (im.size[0]/float(old_size[0]), im.size[1]/float(old_size[1]))
	new_dim = (scale_fac[0] * dat[5][0], scale_fac[1] * dat[5][1])
	new_offset = (scale_fac[0] * dat[3][0], scale_fac[1]*dat[3][1])
	
	if im.mode != 'RGBA':
		im = im.convert('RGBA')
	return im, new_dim, new_offset
	
	
def plot_markers(im, markers, size, offset):
	if markers:
		draw = ImageDraw.Draw(im)
		point_radius = 2
		for point in markers:
			coord = to_coord(point['location'], size)
			coord = map(int, (coord[0] -offset[0], coord[1] - offset[1]))
			draw.rectangle(
				(coord[0] + point_radius/2, coord[1] + point_radius/2, coord[0] - point_radius/2, coord[1] - point_radius/2),
				fill = point['color'])



def draw_inset(im, size, offset, style = 'blue-marble'):
	inm, ndim, noffset = get_map_image((im.size[0]/4,im.size[1]/4), (0,0), 0, style)
	draw = ImageDraw.Draw(inm)
	draw.rectangle((0,0,inm.size[0]-1, inm.size[1]-1), fill = None, outline = "#000000")
	draw.rectangle((1,1,inm.size[0]-2, inm.size[1]-2), fill = None, outline = "#000000")
	rect = (
		(
			offset[0]/float(size[0]) * inm.size[0], 
			offset[1]/float(size[1]) * inm.size[1]
		),
		(	
			offset[0]/float(size[0]) * inm.size[0] + im.size[0]/float(size[0]) * inm.size[0],
			offset[1]/float(size[1]) * inm.size[1] + im.size[1]/float(size[1]) * inm.size[1]
			)
		)
	draw.rectangle(rect, fill = None, outline = "#ff0000")
	im.paste(inm, (0, im.size[1] - (im.size[1]/4)))
	


def plot_path(im, points, color, size, offset):
	if points:
		color = color or "#ff0000"
		
		points = [to_coord(x, size) for x in points]
		points = [map(int, (p[0] -offset[0], p[1] - offset[1])) for p in points]
	
		draw = ImageDraw.Draw(im)
		draw.line(map(tuple, points), fill=color, width =1)
	



def parse_latlong(latlong):
	"""
	Given a string <float>,<float>, return a tuple, (lat, long)
	"""
	latlong =  map(float, latlong.split(","))
	assert -90.0 < latlong[0] < 90.0, "Invalid Latitude - must be float between -90 and 90 degrees" 
	assert -180.0 < latlong[1] < 180.0, "Invalid Longitude - must be float between -180 and 180 degrees"
	return latlong

def parse_zoom(zoom):
	assert -1 < int(zoom) <= 20, "Invalid Zoom - must be integer between 0-20 (inc)"
	return int(zoom)

def parse_size(size):
	x = map(int, size.split("x"))
	assert 0 < x[0] <= 1280 and 0< x[1] <= 640, "Invalid size - must be of form [integer]x[integer] with maximum size 1280x640"
	return x

def parse_inset(inset):
	return inset and str(inset) not in ['0', 'false']

def parse_path(path):
	components = path.split("|")
	assert len(components) >= 3, "Invalid path - not enough args"

	col = components[0]
	
	points = [parse_latlong(x) for x in components[1:]]
	return {'points' : points, 'color' : "" }
	

def parse_markers(markers):
	"""
	===Google Says:===
	
	The markers parameter defines a set of one or more markers
	to attach to the map image. This parameter takes a list of
	up to 50 markers defined by a set of value assignments:

	markers=markerDescriptor1|markerDescriptor2|markerDescriptor3|... etc.

	Note that marker descriptors are separated from each other
	using the pipe character (|). (Note: the pipe character is 
	also %7C in ASCII if you are encoding your URLs.)

	Marker Descriptors

	Each marker descriptor contains a string defining the location
	to place the marker and the visual attributes to use when 
	displaying the marker. These strings contain the following 
	variable values:

    * {latitude} (required) specifies a latitudinal value with
    	precision to 6 decimal places.
    * {longitude} (required) specifies a longitudinal value 
    	with precision to 6 decimal places.
    * {size} (optional) specifies the size of marker from the set
    	 {tiny, mid, small}. If no size parameter is set, the 
    	 marker will appear in its default (normal) size.
    * {color} (optional) specifies a color from the set 
    	{black, brown, green, purple, yellow, blue, gray, orange,
    	 red, white}.
    * {alphanumeric-character} (optional) specifies a single 
    	lowercase alphanumeric character from the set {a-z, 0-9}. 
    	Note that default and mid sized markers are the only 
    	markers capable of displaying an alphanumeric-character
    	parameter. tiny and small markers are not capable of 
    	displaying an alphanumeric-character.

	The latitude and longitude values define the marker's location 
	on the map. If the location is off the map, that marker will 
	not appear in the constructed image.
	
	===
	
	Of course we don't use the same marker image so our parameters
	vary a little - we don't respect the 'size' or 'alphanumeric'
	settings.
	"""
	colors = {
		'black': "#000000",
		'brown': "#999900", 
		'green': "#00ff00", 
		'purple' : "#9900ff", 
		'yellow' : "#FFFFE0", 
		'blue' : "#0000ff", 
		'gray' : "#999999", 
		'orange' : "#FF8040", 
		'red' : "#FF0000", 
		'white': "#FFFFFF"
	}

	markers = markers.split("|")
	m = []
	for marker in markers:
		c = marker.split(",")
		d = { #defaults
			'color' : "#FF0000",
		}
		
		assert len(c)>=2	
		d['location'] = parse_latlong(",".join(c[:2]))
		
		if len(c)>2:
			s = c[2]
			for i in ('tiny', 'mid', 'small'):
				if s.startswith(i):
					s = s[len(i)-1:]

			for i in colors.keys():
				if s.startswith(i):
					s = s[len(i)-1:]		
					d['color'] = colors[i]		
		
		m.append(d)
	
	return m
	